# Laboratory 2
*Task* <br>
To implement 3 structural patterns. I have chosen to implement Adapter, Bridge and Decorator. <br><br>
**Adapter** <br>
This template converts the interface of a class into another interface that the client expects. The adapter allows classes to work together that otherwise could not because of incompatible interfaces.<br>
![alt text](https://github.com/Tolea86/IPP-Labs/blob/master/Lab%202/screen/adapter.JPG) <br><br>
**Bridge**<br>
The Bridge Pattern has a structure similar to an Adapter object, but it has a whole different purpose: it is intended to separate an interface from its implementation so that the two can be independently modified easily. The purpose of an adapter is to change the interface of an existing object.<br>
The Proxy template defines a representative for another object and does not modify its interface.<br>
It decouples an abstraction of its implementation so that the two can vary independently.<br>
![alt text](https://github.com/Tolea86/IPP-Labs/blob/master/Lab%202/screen/bridge.JPG)<br><br>
**Decorator**<br>
The Decorator Pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible derivation alternative for expanding functionality.<br>
Decorators have the same type as decorated objects. It is possible to send as a parameter a decorated object in place of the original object.<br>
The decorator uses the legacy to retrieve the type of the decorated object and the composition to change its behavior. One or more decorators can be used for an object. Objects can be dynamically decorated at the time of execution. Decorator can add his or her own behavior before or after delegation. The decorator lets you add new features without modifying the code.<br>
![alt text](https://github.com/Tolea86/IPP-Labs/blob/master/Lab%202/screen/decorator.JPG)

